\documentclass[12pt]{article}

\usepackage{sbc-template}

\usepackage{graphicx,url}

\usepackage[brazil]{babel}   
\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}

\usepackage{listings}
\usepackage{xcolor}
\usepackage{slashbox}

\lstdefinestyle{customc++}{
  belowcaptionskip=1\baselineskip,
  breaklines=true,
  frame=L,
  xleftmargin=\parindent,
  language=C++,
  showstringspaces=false,
  basicstyle=\footnotesize\ttfamily,
  keywordstyle=\bfseries\color{green!40!black},
  commentstyle=\itshape\color{red!70!black},
  %identifierstyle=\color{blue},
  stringstyle=\color{orange},
}
     
\sloppy

\title{GoSpaces: Uma imeplementação do Espaço de Tuplas em Go}

\author{Matheus B. Nascimento\inst{1},
		Wisllay Vitrio\inst{1}
}

\address{
	Instituto de Informática -- Universidade Federal de Goiás (UFG)\\
	Caixa Postal 131 -- CEP 74.001-970 -- Goiânia -- GO -- Brasil
}

\begin{document} 

\maketitle

\begin{abstract}
In this work a Tuple Space implementation in Go is presented, allowing simultaneous accesss from many proccesses, reading and writing tuples with values of any type.
The implementation was tested using an example that explores parallelism.
With the increase in the number of servers, a speedup increase was achieved.
\end{abstract}
     
\begin{resumo}
Neste trabalho é apresentada uma implementação do espaço de tuplas em Go, permitindo que vários processos o acessem simultaneamente, realizando leituras e escritas de tuplas com valores de qualquer tipo.
A implemnetação foi testada utilizando um exemplo que explora paralelismo.
Ganhos de \emph{speedup} foram obtidos com o aumento no número de servidores.  
\end{resumo}

\section{Introdução}
\label{sec:introducao}

Espaço de tuplas é um conceito de memória associativa para computação distribuída/paralela.
Desenolvido por David Gelernter na Universidade de Yale, teve sua primeira implementação na linguagem de coordenação ``Linda'' (homenagem a uma atriz pornô de nome Linda Lovelace, assim como o nome da linguagem ``Ada'' é uma homenagem à Ada Lovelace~\cite{web:name_linda}).

O espaço de tuplas provê um repositório de tuplas que pode ser acessado concorrentemente por zero ou mais processos.
Por ser baseado em memória associativa, as tuplas são acessadas por seu conteúdo e não por endereços.
As tuplas não estão ligadas à nenhum processo, e qualquer um deles pode inserir, ler ou remover tuplas.
Este desacoplamento total entre as partes integrantes do sistema provido pelo espaço de tuplas é sua principal vantagem.

Várias linguagens têm implementações de espaço de tuplas, sendo a especificação para Java, JavaSpaces~\cite{web:javaspaces}, a mais famosa.
Como parte da tecnologia Jini, JavaSpaces é utilizado em serviços de finanças e telecomunicações para alcançar escalabilidade utilizando processamento paralelo.
Por outro lado, a tecnologia Jini como um todo não é sucesso comercial, e o JavaSpaces não é amplamente utilizado.

Este trabalho apresenta uma implementação e avaliação do conceito de Espaço de Tuplas na linguagem Go~\cite{web:go}, juntamente da apresentação de um possível cenário de uso que se aproveita das vantagens providas.
Diferentemente do que é percebido em outras implementações, o Espaço de Tuplas apresentado neste trabalho utiliza estruturas de dados extras para melhorar o tempo de resposta quando as tuplas são acessadas, tanto para leitura quanto para escrita.

O restante deste artigo é apresentado como se segue:
Na sessão~\ref{sec:tuplespace} a implementação do Espaço de Tuplas e de outros módulos envolvidos é detalhada.
Na sessão~\ref{sec:testes} são discutidas a aplicação, o ambiente e a metodologia utilizada durante os testes.
A sessão~\ref{sec:resultados} apresenta e discute os resultados obtidos, e finalmente a sessão~\ref{sec:conclusao} apresenta as conclusões finais.

\section{O Espaço de Tuplas}
\label{sec:tuplespace}

Como foi descrito na seção \ref{sec:introducao}, o espaço de tuplas permite que
processos se comuniquem sem o conhecimento um do outro, local ou remotamente, 
inserindo e removendo objetos representados por tuplas de valores.
Para realizar o acesso aos dados do espaço de
tuplas, o paradigma oferece três primitivas: \emph{read()}, \emph{take()} e 
\emph{write()}. Esta seção explica o funcionamento de cada uma dessas primitivas e
como foram implementadas levando em consideração as decisões arquiteturais tomadas.

\subsection{Primitivas}
\label{sec:primitivas}

Um dos exemplos de implementação do espaço de tuplas é o JavaSpaces, que foi 
uma solução em Java para o espaço de tuplas. Nele as tuplas são armazenadas como uma 
sequência de valores primitivos \emph(int, double, String, etc.) através da primitiva
\emph{write()}. E os valores são lidos passando-se um \emph{template}, que representa
a tupla procurada. A estrutura do template é a mesma da tupla, e serve como filtro 
para as primitivas \emph{read()} e \emph{take()}. Essas primitivas retornam uma tupla 
que combine com o template passado como parâmetro. No caso do JavaSpaces, o template 
é uma tupla, onde cada valor pode ser nulo, significando que qualquer valor é valido 
para aquela posição da tupla ou um valor específico, o qual deve combinar com a tupla  
procurada.

Na solução de espaço de tuplas desenvolvida nesse trabalho, a qual foi dada
o nome de GoSpaces, foi utilizada a linguagem Go, e seguimos o mesmo modelo  do 
JavaSpaces para a representação 
das tuplas, para escrita e leitura, com a diferença de que qualquer tipo de dado que 
possa ser serializado como atributo de uma tupla é aceito. A consulta também é 
realizada sobre 
templates, utilizando o mesmo conceto do JavaSpaces. Um \emph{read()} ou 
procura por uma tupla que combine com o template e a retorna. Uma chamada ao método 
\emph{take()} também procura por uma tupla, mas a remove do espaço de tuplas, quando 
encontrada. Durante uma operação de \emph{write()}, uma nova tupla é criada, mesmo 
que uma tupla de mesmo valor já tenha sido inserida anteriormente, permitindo 
múltiplas cópias da mesma tupla no espaço de tuplas. 

\subsection{Acesso Paralelo}
\label{sec:acesso_paralelo}

Para um espaço de tuplas ser útil, é necessário que permita acessos de
modo simultâneo e eficientemente. Para garantir isso, o GoSpaces leva em consideração
as seguintes decisões arquiteturais.

\begin{enumerate}
	\item Leituras devem encontrar uma tupla que corresponde ao template de modo 
	eficiente
	\item Escritas não podem ocorrer simultâneamente com leituras e vice-versa
\end{enumerate}

A primeira decisão levou a criação de um sistema de índices invertidos que permitem
encontrar tuplas rapidamente a partir de templates. Primeiramente, cada tupla é
inserida no espaço de tuplas é associada a um identificador único. Esse identificador
é utilizado para inserir referências a tupla nos índices invertidos associados a
cada atributo contido na tupla. Cada índice mantém uma lista de identificadores para 
cada valor presente no espaço de tuplas, como na figura \ref{fig:indiceinvertido}.
Isso permite que os casamentos por template sejam realizados rapidamente, bastando 
realizar a interseção daslistas de identificadores relacionados a cada atributo não
nulo contido na consulta. Outro nível de índice foi desenvolvido para separar as
tuplas por aridade, permitindo que tuplas de tamanhos diferentes sejam armazenadas em 
índices diferentes, reduzindo ainda mais o espaço de busca, como ilustrado na figura 
\ref{fig:indicetuplas}

\begin{figure}[h]
	\center
	\includegraphics[width=.55\textwidth]{img/indice_invertido.png}
	\caption{Índice invertido}
	\label{fig:indiceinvertido}
\end{figure}

\begin{figure}[h]
	\center
	\includegraphics[width=.8\textwidth]{img/indice_tuplas.png}
	\caption{Índice separado por aridade das tuplas}
	\label{fig:indicetuplas}
\end{figure}

Como consequência do sistema de indexação, uma operação de escrita deve atualizar 
vários indices para uma única tupla, dificultando a imeplementação de um sistema que
permita escritas e leituras concorrentemente. Sendo assim, a segunda decisão 
arquitetural fez com que o espaço de tuplas execute apenas uma operação por vez 
quando uma escrita ocorre. Isso degrada a eficiência do espaço de tuplas quando 
muitas escritas são realizadas, ao custo de operações de leitura rápidas e 
simultâneas.

Para garantir que as operações de \emph{take()} não bloqueiem todo o espaço de 
tuplas, estas são executadas como de leitura, assim como as chamadas \emph{read()}.
Porém, quando uma tupla é encontrada, esta é removida apenas do índice central, que 
associa o identificador aos dados utilizando uma tabela hash padrão da linguagem Go.
O proximo processo que tentar remover essa mesma tuplas a encontrará no índice, mas
não conseguirá utilizá-la, pois já foi removida do índice central.

\subsection{Chamadas Assincronas}

O espaço de tuplas também implementa o conceito de leituras com \emph{timeout}. 
Quando um \emph{timeout} é configurado em uma operação, uma tupla que corresponde ao
template é procurada no espaço de tuplas, e caso não seja encontrada nehuma, a 
requisição é alocada a uma fila de espera. Desse modo, quando uma operação 
\emph{write} é realizada, a tupla a ser inserida deve primeiramente ser testada 
contra cada requisição na fila de espera para evitar que uma nova requisição
obtenha a tupla antes de uma que esteja a espera. Essa busca na fila de espera é 
necessária para
que requisições do tipo \emph{take()} sejam tratadas corretamente, pois a fila é 
seguida por ordem de chegada.

Para imeplementar o sistema de \emph{timeout}, cada requisição de leitura em espera
é associada a um \emph{channel} Go, através do qual uma tupla pode ser adicionada
quando disponível. Assim é esperado uma tupla que combina com o template, ou um aviso 
de \emph{timeout}, o que ocorrer primeiro.

\subsection{\emph{Leasing}}

Cada tupla que é inserida no espaço de tuplas deve ter um tempo máximo que pode 
permanecer lá. Esse tampo é chamado de \emph{leasing}, e garante que, mesmo que 
uma tupla nunca seja removida por um \emph{take()}, seu conteúdo seja descartado após 
um período de tempo. Para realizar a limpeza das tuplas antigas, um coletor de lixo
rudimentar percorre os índices em períodos regulares em busca de tuplas que tenham 
expirado o \emph{leasing}. Com isso, as tuplas que não foram removidas dos índices 
secundários após um \emph{take()} são limpas após um período de tempo, reduzindo
o espaço ocupado pelos índices.

\section{Testes}
\label{sec:testes}

Um cenário de uso em que pode-se utilizar o Espaço de Tuplas de modo vantajoso é o padrão de projeto Mestre-Escravo~\cite{web:master_slave}.
O desacoplamento total entre as partes, provido pela comunicação assíncrona utilizando o Espaço de Tuplas, permite que os mestres e escravos não saibam da localização, ou até mesmo da existência uns dos outros.

\subsection{Aplicação}
\label{sec:aplicacao}

No escopo deste trabalho, a fim de testar o Espaço de Tuplas, foi implementada uma aplicação para que servidores disponibilizem algumas de suas funções remotamente para que clientes possam utilizar seu poder de processamento.
Um diagrama geral da solução pode ser visto na figura~\ref{fig:diagrama_geral}

\begin{figure}[h]
	\center
	\includegraphics[width=.8\textwidth]{img/arquitetura.png}
	\caption{Visão geral da arquitetura implementada para a aplicação de testes}
	\label{fig:diagrama_geral}
\end{figure}

A aplicação consiste de um módulo \emph{``Middleware''}, presente tanto nos servidores quanto nos clientes, que trabalha como interface para a comunicação com o Espaço de Tuplas.
Este módulo apresenta para seus usuários uma interface mais específica de Requisição-Resposta, e permite ainda que objetos servidores (chamados ``serviços'') se disponibilizem à ``trabalhar'' para algum cliente.

Serviço é uma interface do \emph{Middleware} implementada por objetos que desejam disponibilizar suas funções para execução ao haver a requisição de clientes.
Já os clientes possuem \emph{``Stubs''}, que tem definições de funções parecidas com as do seu serviço correspondente, mas ao invés de executarem estas funções, enviam requisições, por meio do \emph{Middleware}, aos objetos servidores, para que estes as executem.

Por simplicidade, assume-se que tanto os servidores quanto os clientes sabem a localização do Espaço de Tuplas, já que este disponibiliza a sua interface como serviços RPC.
Assume-se também que os \emph{``Stubs''} e Serviços são definidos previamente e ambos sabem a definição das chamadas correspondentes no outro módulo, assim como o formato e a ordem de dados esperada, tanto para as requisições quanto para as respostas.

\subsection{Configurações}
\label{sec:configuracoes}

Para a realização dos testes, foi implementado um serviço que disponibiliza a aproximação da integral de uma função polinomial utilizando o método de soma de Riemann~\cite{web:riemann}.
O intervalo do eixo $x$ de onde se deseja a integral é dividido partes de tamanho igual e é criada uma requisição para a execução da soma de Riemann para cada parte, como pode ser visto na figura~\ref{fig:riemann}.

\begin{figure}[h]
	\center
	\includegraphics[width=.75\textwidth]{img/integral.png}
	\caption{Aproximação da integral pela soma de Riemann}
	\label{fig:riemann}
\end{figure}

Foram utilizadas uma máquina para o cliente que gera as requisições de integral, 
uma máquina de 8 núcleos de processamento, para atuar como servidor, recebendo os 
pedidos de cálculos de integral e realizando as somas de Riemann, e uma máquina
virtual na plataforma Azure, da Microsoft, com dois núcleos, para atuar como espaço 
de tuplas.

Tanto clientes como servidores estavam localizados na mesma rede, mas a latência 
destes para o espaço de tuplas era de aproximadamente 130ms. Com isso, foi possível
notar como os tempos de comunicação influenciaram nos resultados dos testes. 

\subsection{Metodologia}
\label{sec:metodologia}

Para cada caso de teste com parametrizações diferentes, a aproximação da integral foi realizada 30 vezes.
Os casos de teste foram configurados com o cliente dividindo o cálculo da integral em 8, 16, 32, 64 e 128 partes diferentes (requisições enviadas pelo \emph{Middleware} para o Espaço de Tuplas).
Para cada número de requisições, foram executados casos de teste diferentes com o servidor utilizando 1, 2, 4 e 8 gorotinas, simulando múltiplos servidores.

\section{Resultados}
\label{sec:resultados}

As médias dos tempos de execução e os devios padrão das 30 execuções, medidos no cliente, podem ser observado para as configurações de cada caso de teste na tablea~\ref{tab:tempo_de_execucao}.

\begin{table}[h]
	\caption{Tempo de execução em segundos (média e desvio padrão)}
	\label{tab:tempo_de_execucao}
	\begin{tabular}{|c|c|c|c|c|}
	\hline
	\backslashbox{Partes}{Servidores}	& 1 & 2 & 4 & 8 \\ \hline
	8   & $19,59 \pm 0,49$ & $10,26 \pm 0,37$ & $6,97 \pm 0,50$ & $6,41 \pm 0,23$ \\ \hline
	16  & $21,81 \pm 0,28$ & $11,32 \pm 0,33$ & $7,29 \pm 0,27$ & $6,98 \pm 0,48$ \\ \hline
	32  & $26,72 \pm 0,76$ & $14,35 \pm 1,02$ & $8,54 \pm 0,62$ & $6,93 \pm 0,47$ \\ \hline
	64  & $36,04 \pm 0,53$ & $20,60 \pm 1,63$ & $12,07 \pm 2,61$ & $11,04 \pm 1,53$ \\ \hline
	128 & $59,55 \pm 2,16$ & $31,60 \pm 1,06$ & $20,60 \pm 2,97$ & $21,97 \pm 2,29$ \\ \hline
	\end{tabular}
\end{table}

Na figura~\ref{fig:performance_gorotinas} temos uma visualização da tabela apresentada, mostrando para cada número de divisões do cálculo da integral, qual o tempo de resposta obtido aumentando-se o número de gorotinas disponíveis para execução simultânea das requisições no servidor.

\begin{figure}[h]
	\center
	\includegraphics[width=\textwidth]{img/performance2.png}
	\caption{Tempo de resposta obtido para cada número de requisições enviadas}
	\label{fig:performance_gorotinas}
\end{figure}

Pode-se perceber ganhos com a paralelização, principalmente até 4 gorotinas, pois a máquina utilizada para testes possui 4 núcleos reais (8 núcleos lógicos por \emph{hyperthreading}).
Portanto, sem mais núcleos para distribuir o trabalho de maneira realmente paralela, os ganhos entre 4 e 8 gorotinas são pequenos.

Na figura~\ref{fig:performance_partes} temos uma visualização centrada no aumento do número de partes em que a integral foi dividida.
Cada parte é enviada como uma requisição diferente para o Espaço de Tuplas, a ser executada por alguma gorotina de algum objeto servidor.

\begin{figure}[h!]
	\center
	\includegraphics[width=\textwidth]{img/performance1.png}
	\caption{Tempo de resposta obtido para cada número de servidores simultâneos}
	\label{fig:performance_partes}
\end{figure}

Percebe-se que o aumento do número de servidores disponíveis gera um aumento menor do tempo de execução.
Porém, o aumento do número de requisições no Espaço de Tuplas, e o consequente aumento na quantidade de escrita de tuplas degrada consideravelmente o sistema, mesmo com o maior número de servidores utilizado.

\section{Conclusão}
\label{sec:conclusao}

O conceito de Espaço de Tuplas apresenta vantagens para a comunicação distribuída entre processos por suas características de desacoplamento e permitir que os comunicantes sequer se conheçam.
Este trabalho apresenta uma implementação de Espaço de Tuplas baseada que provê as primitivas básicas de \emph{write()}, \emph{read()} e \emph{take()}, fazendo o casamento de tuplas baseado na especificação da tecnologia JavaSpaces.
Além disso, a implementação apresentada possui algumas estruturas internas de indexação de tuplas para diminuir o espaço de busca e consequêntemente reduzir o tempo de resposta, principalmente para leituras.

Uma aplicação de exemplo foi implementada, que permite a execução remota de funções entre clientes e servidores totalmente desacoplados e que nem mesmo se conhecem.
Para testar esta aplicação, a aproximação de integral por soma de Riemann foi utilizada.

Os resultados mostram um ganho significativo no tempo de resposta quando mais servidores simultâneos executam as requisições de forma paralela.
Porém quanto maior o número de requisições enviadas ao Espaço de Tuplas, o overhead causado tanto pelas operações de escrita quanto pelas operações de leitura gera uma degradação no tempo total de execução.

\bibliographystyle{sbc}
\bibliography{sbc-template}

\end{document}
